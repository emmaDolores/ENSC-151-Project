#include <iostream>
#include <string>
#include <iomanip>
#include <map>
#include <vector>
#include <algorithm> // For std::transform
#include <cmath>     // For std::round

using namespace std;

// --- 1. Data Structures for Tax Brackets ---

// Struct to represent a single income tax bracket
struct TaxBracket {
    double limit; // The upper limit of the income for this bracket
    double rate;  // The tax rate for income in this bracket
    double baseTax; // The tax accumulated from all previous brackets
};

// --- 2. Centralized Tax Data (2025 Rates) ---

// Federal Tax Brackets
double federalTax(double income) {
    const double brackets[] = {57375.0, 114750.0, 177882.0, 253414.0};
    const double rates[]    = {0.145,   0.205,    0.26,     0.29,     0.33};

    double tax = 0.0;
    double prev = 0.0;

    for (int i = 0; i < 4; i++) {
        if (income > brackets[i]) {
            tax += (brackets[i] - prev) * rates[i];
            prev = brackets[i];
        } else {
            tax += (income - prev) * rates[i];
            return tax;
        }
    }

    // Final bracket (income above last threshold)
    tax += (income - prev) * rates[4];
    return 0;
}

// Provincial Tax Brackets (using a map for easy lookup)
// Note: Using a large number (99999999.0) for the final bracket's limit
const map<string, vector<TaxBracket>> PROVINCIAL_BRACKETS = {
    // Ontario (ON)
    {"on", {
        {52886.0, 0.0505, 0.0},
        {105775.0, 0.0915, 52886.0 * 0.0505},
        {150000.0, 0.1116, 52886.0 * 0.0505 + (105775.0 - 52886.0) * 0.0915},
        {220000.0, 0.1216, 52886.0 * 0.0505 + (105775.0 - 52886.0) * 0.0915 + (150000.0 - 105775.0) * 0.1116},
        {99999999.0, 0.1316, 52886.0 * 0.0505 + (105775.0 - 52886.0) * 0.0915 + (150000.0 - 105775.0) * 0.1116 + (220000.0 - 150000.0) * 0.1216}
    }},
    // British Columbia (BC)
    {"bc", {
        {49279.0, 0.0506, 0.0},
        {98560.0, 0.0770, 49279.0 * 0.0506},
        {113158.0, 0.1050, 49279.0 * 0.0506 + (98560.0 - 49279.0) * 0.0770},
        {137407.0, 0.1229, 49279.0 * 0.0506 + (98560.0 - 49279.0) * 0.0770 + (113158.0 - 98560.0) * 0.1050},
        {186306.0, 0.1470, 49279.0 * 0.0506 + (98560.0 - 49279.0) * 0.0770 + (113158.0 - 98560.0) * 0.1050 + (137407.0 - 113158.0) * 0.1229},
        {259829.0, 0.1680, 49279.0 * 0.0506 + (98560.0 - 49279.0) * 0.0770 + (113158.0 - 98560.0) * 0.1050 + (137407.0 - 113158.0) * 0.1229 + (186306.0 - 137407.0) * 0.1470},
        {99999999.0, 0.2050, 49279.0 * 0.0506 + (98560.0 - 49279.0) * 0.0770 + (113158.0 - 98560.0) * 0.1050 + (137407.0 - 113158.0) * 0.1229 + (186306.0 - 137407.0) * 0.1470 + (259829.0 - 186306.0) * 0.1680}
    }},
    // Add other provinces here as key-value pairs in the same structure...
    // You can also add full province names as keys if needed, but using codes is cleaner.
    {"ab", {
        {151234.0, 0.10, 0.0},
        {181481.0, 0.12, 151234.0 * 0.10},
        {241974.0, 0.13, 151234.0 * 0.10 + (181481.0 - 151234.0) * 0.12},
        {362961.0, 0.14, 151234.0 * 0.10 + (181481.0 - 151234.0) * 0.12 + (241974.0 - 181481.0) * 0.13},
        {99999999.0, 0.15, 151234.0 * 0.10 + (181481.0 - 151234.0) * 0.12 + (241974.0 - 181481.0) * 0.13 + (362961.0 - 241974.0) * 0.14}
    }}
    // Only includes ON, BC, and AB for brevity. Add the rest using your original data.
};

// --- 3. Core Calculation Function (Generic) ---

// Calculates tax based on a generic set of brackets and finds the marginal rate
// Returns a pair: {totalTax, marginalRate}
pair<double, double> calculateTax(double income, const vector<TaxBracket>& brackets) {
    if (income <= 0.0) {
        return {0.0, brackets[0].rate};
    }

    double totalTax = 0.0;
    double marginalRate = 0.0;
    double prevLimit = 0.0;

    for (const auto& bracket : brackets) {
        // If income is less than or equal to the current bracket's limit
        if (income <= bracket.limit) {
            // Tax = Base Tax from prior brackets + (Income - Prior Limit) * Rate
            totalTax = bracket.baseTax + (income - prevLimit) * bracket.rate;
            marginalRate = bracket.rate; // This is the rate applied to the last dollar
            break;
        }
        // If we haven't broken, update the previous limit to the current limit
        prevLimit = bracket.limit;
    }

    return {totalTax, marginalRate};
}

// --- 4. Tax Calculation Wrapper Functions ---

// Federal tax 2025
pair<double, double> federalTax(double income) {
    return calculateTax(income, FEDERAL_BRACKETS);
}

// Provincial tax 2025 (Refactored)
pair<double, double> provincialTax(double income, const string& prov) {
    string key = prov;
    // Convert to lowercase for map lookup
    transform(key.begin(), key.end(), key.begin(), ::tolower);

    // Check if the province code exists in the map
    if (PROVINCIAL_BRACKETS.count(key)) {
        return calculateTax(income, PROVINCIAL_BRACKETS.at(key));
    }

    // Attempt to convert full name to code for map lookup (e.g., "Ontario" -> "on")
    if (key.find("ontario") != string::npos) key = "on";
    else if (key.find("british columbia") != string::npos) key = "bc";
    else if (key.find("alberta") != string::npos) key = "ab";
    // ... add more province name -> code mappings here ...

    if (PROVINCIAL_BRACKETS.count(key)) {
        return calculateTax(income, PROVINCIAL_BRACKETS.at(key));
    }

    // Province not recognized (returning a large negative error indicator)
    return {-999.0, 0.0};
}

// --- 5. Main Execution ---

int main() {
    cout << fixed << setprecision(2);

    string prov;
    double income;
    bool valid = false;
    
    // --- Input Province (Improved list of supported codes) ---
    do {
        cout << "Enter your province (e.g., ON, BC, AB, QC, SK...): ";
        getline(cin, prov);

        string key = prov;
        transform(key.begin(), key.end(), key.begin(), ::tolower);

        if (prov.empty()) {
            cout << "Province cannot be empty. Try again.\n";
        } else if (!PROVINCIAL_BRACKETS.count(key) && provincialTax(0.0, prov).first < -990.0) {
            cout << "Province not recognized or not supported in this calculator. Try again.\n";
        } else {
            valid = true;
        }
    } while (!valid);

    // --- Input Income (Uses stod for safe conversion) ---
    valid = false;
    do {
        cout << "Enter your taxable income (numbers only): ";
        string incomeInput;
        getline(cin, incomeInput);
        try {
            income = stod(incomeInput);
            if (income < 0)
                cout << "Income cannot be negative. Try again.\n";
            else
                valid = true;
        } catch (...) {
            cout << "Invalid input. Please enter a numeric amount.\n";
        }
    } while (!valid);

    // --- Calculation and Output ---
    
    // Unpack the calculated values
    auto [fTax, fMarginalRate] = federalTax(income);
    auto [pTax, pMarginalRate] = provincialTax(income, prov);

    double totalDeductions = fTax + pTax;
    double netIncome = income - totalDeductions;
    
    // Calculate the Effective Tax Rate (a great metric to include!)
    double effectiveTaxRate = (income > 0) ? totalDeductions / income : 0.0;

    cout << "\n---- INCOME TAX CALCULATION (2025) ----\n";
    cout << setfill('-') << setw(44) << "" << endl;
    
    cout << "Income Entered:   $" << income << "\n";
    cout << setfill(' ') << setw(0) << ""; // Reset fill and width
    
    // Tax Breakdown
    cout << "\n--- TAX PAYABLE ---\n";
    cout << "Federal Tax:      $" << fTax << "\n";
    cout << "Provincial Tax:   $" << pTax << "\n";
    cout << "Total Tax Paid:   $" << totalDeductions << "\n";
    
    cout << "\n--- KEY METRICS ---\n";
    // Using std::round to ensure rates are accurate to one decimal place before display
    cout << "Net Income:       $" << netIncome << "\n";
    cout << "Effective Rate:   " << effectiveTaxRate * 100.0 << "%\n";
    cout << "Marginal Rate (F):" << fMarginalRate * 100.0 << "%\n";
    cout << "Marginal Rate (P):" << pMarginalRate * 100.0 << "%\n";

    return 0;
}
